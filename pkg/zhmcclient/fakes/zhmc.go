// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.ibm.com/zhmcclient/golang-zhmcclient/pkg/zhmcclient"
)

type ZhmcAPI struct {
	CreateAdapterStub        func(string, *zhmcclient.Adapter) (*zhmcclient.Adapter, error)
	createAdapterMutex       sync.RWMutex
	createAdapterArgsForCall []struct {
		arg1 string
		arg2 *zhmcclient.Adapter
	}
	createAdapterReturns struct {
		result1 *zhmcclient.Adapter
		result2 error
	}
	createAdapterReturnsOnCall map[int]struct {
		result1 *zhmcclient.Adapter
		result2 error
	}
	CreateNicStub        func(string, *zhmcclient.NIC) (*zhmcclient.NIC, error)
	createNicMutex       sync.RWMutex
	createNicArgsForCall []struct {
		arg1 string
		arg2 *zhmcclient.NIC
	}
	createNicReturns struct {
		result1 *zhmcclient.NIC
		result2 error
	}
	createNicReturnsOnCall map[int]struct {
		result1 *zhmcclient.NIC
		result2 error
	}
	DeleteAdapterStub        func(string) error
	deleteAdapterMutex       sync.RWMutex
	deleteAdapterArgsForCall []struct {
		arg1 string
	}
	deleteAdapterReturns struct {
		result1 error
	}
	deleteAdapterReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteJobStub        func(string) error
	deleteJobMutex       sync.RWMutex
	deleteJobArgsForCall []struct {
		arg1 string
	}
	deleteJobReturns struct {
		result1 error
	}
	deleteJobReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteNicStub        func(string, string) error
	deleteNicMutex       sync.RWMutex
	deleteNicArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteNicReturns struct {
		result1 error
	}
	deleteNicReturnsOnCall map[int]struct {
		result1 error
	}
	GetAdaptersStub        func(string) []zhmcclient.Adapter
	getAdaptersMutex       sync.RWMutex
	getAdaptersArgsForCall []struct {
		arg1 string
	}
	getAdaptersReturns struct {
		result1 []zhmcclient.Adapter
	}
	getAdaptersReturnsOnCall map[int]struct {
		result1 []zhmcclient.Adapter
	}
	GetCPCsStub        func() []zhmcclient.CPC
	getCPCsMutex       sync.RWMutex
	getCPCsArgsForCall []struct {
	}
	getCPCsReturns struct {
		result1 []zhmcclient.CPC
	}
	getCPCsReturnsOnCall map[int]struct {
		result1 []zhmcclient.CPC
	}
	GetLPARsStub        func(string) []zhmcclient.LPAR
	getLPARsMutex       sync.RWMutex
	getLPARsArgsForCall []struct {
		arg1 string
	}
	getLPARsReturns struct {
		result1 []zhmcclient.LPAR
	}
	getLPARsReturnsOnCall map[int]struct {
		result1 []zhmcclient.LPAR
	}
	GetNicStub        func(string, string) (*zhmcclient.NIC, error)
	getNicMutex       sync.RWMutex
	getNicArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getNicReturns struct {
		result1 *zhmcclient.NIC
		result2 error
	}
	getNicReturnsOnCall map[int]struct {
		result1 *zhmcclient.NIC
		result2 error
	}
	GetNicsStub        func(string, string) []zhmcclient.NIC
	getNicsMutex       sync.RWMutex
	getNicsArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getNicsReturns struct {
		result1 []zhmcclient.NIC
	}
	getNicsReturnsOnCall map[int]struct {
		result1 []zhmcclient.NIC
	}
	ListAdaptersStub        func(string) ([]zhmcclient.Adapter, error)
	listAdaptersMutex       sync.RWMutex
	listAdaptersArgsForCall []struct {
		arg1 string
	}
	listAdaptersReturns struct {
		result1 []zhmcclient.Adapter
		result2 error
	}
	listAdaptersReturnsOnCall map[int]struct {
		result1 []zhmcclient.Adapter
		result2 error
	}
	ListCPCsStub        func() ([]zhmcclient.CPC, error)
	listCPCsMutex       sync.RWMutex
	listCPCsArgsForCall []struct {
	}
	listCPCsReturns struct {
		result1 []zhmcclient.CPC
		result2 error
	}
	listCPCsReturnsOnCall map[int]struct {
		result1 []zhmcclient.CPC
		result2 error
	}
	ListLPARsStub        func(string) ([]zhmcclient.LPAR, error)
	listLPARsMutex       sync.RWMutex
	listLPARsArgsForCall []struct {
		arg1 string
	}
	listLPARsReturns struct {
		result1 []zhmcclient.LPAR
		result2 error
	}
	listLPARsReturnsOnCall map[int]struct {
		result1 []zhmcclient.LPAR
		result2 error
	}
	ListNicsStub        func(string) ([]string, error)
	listNicsMutex       sync.RWMutex
	listNicsArgsForCall []struct {
		arg1 string
	}
	listNicsReturns struct {
		result1 []string
		result2 error
	}
	listNicsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	MountIsoImageStub        func(string, string, string) error
	mountIsoImageMutex       sync.RWMutex
	mountIsoImageArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	mountIsoImageReturns struct {
		result1 error
	}
	mountIsoImageReturnsOnCall map[int]struct {
		result1 error
	}
	QueryJobStub        func(string) (*zhmcclient.Job, error)
	queryJobMutex       sync.RWMutex
	queryJobArgsForCall []struct {
		arg1 string
	}
	queryJobReturns struct {
		result1 *zhmcclient.Job
		result2 error
	}
	queryJobReturnsOnCall map[int]struct {
		result1 *zhmcclient.Job
		result2 error
	}
	StartLPARStub        func(string) (string, error)
	startLPARMutex       sync.RWMutex
	startLPARArgsForCall []struct {
		arg1 string
	}
	startLPARReturns struct {
		result1 string
		result2 error
	}
	startLPARReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	StopLPARStub        func(string) (string, error)
	stopLPARMutex       sync.RWMutex
	stopLPARArgsForCall []struct {
		arg1 string
	}
	stopLPARReturns struct {
		result1 string
		result2 error
	}
	stopLPARReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	UpdateLparPropertiesStub        func(string, map[string]string) (*zhmcclient.LPAR, error)
	updateLparPropertiesMutex       sync.RWMutex
	updateLparPropertiesArgsForCall []struct {
		arg1 string
		arg2 map[string]string
	}
	updateLparPropertiesReturns struct {
		result1 *zhmcclient.LPAR
		result2 error
	}
	updateLparPropertiesReturnsOnCall map[int]struct {
		result1 *zhmcclient.LPAR
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ZhmcAPI) CreateAdapter(arg1 string, arg2 *zhmcclient.Adapter) (*zhmcclient.Adapter, error) {
	fake.createAdapterMutex.Lock()
	ret, specificReturn := fake.createAdapterReturnsOnCall[len(fake.createAdapterArgsForCall)]
	fake.createAdapterArgsForCall = append(fake.createAdapterArgsForCall, struct {
		arg1 string
		arg2 *zhmcclient.Adapter
	}{arg1, arg2})
	stub := fake.CreateAdapterStub
	fakeReturns := fake.createAdapterReturns
	fake.recordInvocation("CreateAdapter", []interface{}{arg1, arg2})
	fake.createAdapterMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) CreateAdapterCallCount() int {
	fake.createAdapterMutex.RLock()
	defer fake.createAdapterMutex.RUnlock()
	return len(fake.createAdapterArgsForCall)
}

func (fake *ZhmcAPI) CreateAdapterCalls(stub func(string, *zhmcclient.Adapter) (*zhmcclient.Adapter, error)) {
	fake.createAdapterMutex.Lock()
	defer fake.createAdapterMutex.Unlock()
	fake.CreateAdapterStub = stub
}

func (fake *ZhmcAPI) CreateAdapterArgsForCall(i int) (string, *zhmcclient.Adapter) {
	fake.createAdapterMutex.RLock()
	defer fake.createAdapterMutex.RUnlock()
	argsForCall := fake.createAdapterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ZhmcAPI) CreateAdapterReturns(result1 *zhmcclient.Adapter, result2 error) {
	fake.createAdapterMutex.Lock()
	defer fake.createAdapterMutex.Unlock()
	fake.CreateAdapterStub = nil
	fake.createAdapterReturns = struct {
		result1 *zhmcclient.Adapter
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) CreateAdapterReturnsOnCall(i int, result1 *zhmcclient.Adapter, result2 error) {
	fake.createAdapterMutex.Lock()
	defer fake.createAdapterMutex.Unlock()
	fake.CreateAdapterStub = nil
	if fake.createAdapterReturnsOnCall == nil {
		fake.createAdapterReturnsOnCall = make(map[int]struct {
			result1 *zhmcclient.Adapter
			result2 error
		})
	}
	fake.createAdapterReturnsOnCall[i] = struct {
		result1 *zhmcclient.Adapter
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) CreateNic(arg1 string, arg2 *zhmcclient.NIC) (*zhmcclient.NIC, error) {
	fake.createNicMutex.Lock()
	ret, specificReturn := fake.createNicReturnsOnCall[len(fake.createNicArgsForCall)]
	fake.createNicArgsForCall = append(fake.createNicArgsForCall, struct {
		arg1 string
		arg2 *zhmcclient.NIC
	}{arg1, arg2})
	stub := fake.CreateNicStub
	fakeReturns := fake.createNicReturns
	fake.recordInvocation("CreateNic", []interface{}{arg1, arg2})
	fake.createNicMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) CreateNicCallCount() int {
	fake.createNicMutex.RLock()
	defer fake.createNicMutex.RUnlock()
	return len(fake.createNicArgsForCall)
}

func (fake *ZhmcAPI) CreateNicCalls(stub func(string, *zhmcclient.NIC) (*zhmcclient.NIC, error)) {
	fake.createNicMutex.Lock()
	defer fake.createNicMutex.Unlock()
	fake.CreateNicStub = stub
}

func (fake *ZhmcAPI) CreateNicArgsForCall(i int) (string, *zhmcclient.NIC) {
	fake.createNicMutex.RLock()
	defer fake.createNicMutex.RUnlock()
	argsForCall := fake.createNicArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ZhmcAPI) CreateNicReturns(result1 *zhmcclient.NIC, result2 error) {
	fake.createNicMutex.Lock()
	defer fake.createNicMutex.Unlock()
	fake.CreateNicStub = nil
	fake.createNicReturns = struct {
		result1 *zhmcclient.NIC
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) CreateNicReturnsOnCall(i int, result1 *zhmcclient.NIC, result2 error) {
	fake.createNicMutex.Lock()
	defer fake.createNicMutex.Unlock()
	fake.CreateNicStub = nil
	if fake.createNicReturnsOnCall == nil {
		fake.createNicReturnsOnCall = make(map[int]struct {
			result1 *zhmcclient.NIC
			result2 error
		})
	}
	fake.createNicReturnsOnCall[i] = struct {
		result1 *zhmcclient.NIC
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) DeleteAdapter(arg1 string) error {
	fake.deleteAdapterMutex.Lock()
	ret, specificReturn := fake.deleteAdapterReturnsOnCall[len(fake.deleteAdapterArgsForCall)]
	fake.deleteAdapterArgsForCall = append(fake.deleteAdapterArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteAdapterStub
	fakeReturns := fake.deleteAdapterReturns
	fake.recordInvocation("DeleteAdapter", []interface{}{arg1})
	fake.deleteAdapterMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) DeleteAdapterCallCount() int {
	fake.deleteAdapterMutex.RLock()
	defer fake.deleteAdapterMutex.RUnlock()
	return len(fake.deleteAdapterArgsForCall)
}

func (fake *ZhmcAPI) DeleteAdapterCalls(stub func(string) error) {
	fake.deleteAdapterMutex.Lock()
	defer fake.deleteAdapterMutex.Unlock()
	fake.DeleteAdapterStub = stub
}

func (fake *ZhmcAPI) DeleteAdapterArgsForCall(i int) string {
	fake.deleteAdapterMutex.RLock()
	defer fake.deleteAdapterMutex.RUnlock()
	argsForCall := fake.deleteAdapterArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) DeleteAdapterReturns(result1 error) {
	fake.deleteAdapterMutex.Lock()
	defer fake.deleteAdapterMutex.Unlock()
	fake.DeleteAdapterStub = nil
	fake.deleteAdapterReturns = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) DeleteAdapterReturnsOnCall(i int, result1 error) {
	fake.deleteAdapterMutex.Lock()
	defer fake.deleteAdapterMutex.Unlock()
	fake.DeleteAdapterStub = nil
	if fake.deleteAdapterReturnsOnCall == nil {
		fake.deleteAdapterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAdapterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) DeleteJob(arg1 string) error {
	fake.deleteJobMutex.Lock()
	ret, specificReturn := fake.deleteJobReturnsOnCall[len(fake.deleteJobArgsForCall)]
	fake.deleteJobArgsForCall = append(fake.deleteJobArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteJobStub
	fakeReturns := fake.deleteJobReturns
	fake.recordInvocation("DeleteJob", []interface{}{arg1})
	fake.deleteJobMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) DeleteJobCallCount() int {
	fake.deleteJobMutex.RLock()
	defer fake.deleteJobMutex.RUnlock()
	return len(fake.deleteJobArgsForCall)
}

func (fake *ZhmcAPI) DeleteJobCalls(stub func(string) error) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = stub
}

func (fake *ZhmcAPI) DeleteJobArgsForCall(i int) string {
	fake.deleteJobMutex.RLock()
	defer fake.deleteJobMutex.RUnlock()
	argsForCall := fake.deleteJobArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) DeleteJobReturns(result1 error) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = nil
	fake.deleteJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) DeleteJobReturnsOnCall(i int, result1 error) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = nil
	if fake.deleteJobReturnsOnCall == nil {
		fake.deleteJobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteJobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) DeleteNic(arg1 string, arg2 string) error {
	fake.deleteNicMutex.Lock()
	ret, specificReturn := fake.deleteNicReturnsOnCall[len(fake.deleteNicArgsForCall)]
	fake.deleteNicArgsForCall = append(fake.deleteNicArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteNicStub
	fakeReturns := fake.deleteNicReturns
	fake.recordInvocation("DeleteNic", []interface{}{arg1, arg2})
	fake.deleteNicMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) DeleteNicCallCount() int {
	fake.deleteNicMutex.RLock()
	defer fake.deleteNicMutex.RUnlock()
	return len(fake.deleteNicArgsForCall)
}

func (fake *ZhmcAPI) DeleteNicCalls(stub func(string, string) error) {
	fake.deleteNicMutex.Lock()
	defer fake.deleteNicMutex.Unlock()
	fake.DeleteNicStub = stub
}

func (fake *ZhmcAPI) DeleteNicArgsForCall(i int) (string, string) {
	fake.deleteNicMutex.RLock()
	defer fake.deleteNicMutex.RUnlock()
	argsForCall := fake.deleteNicArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ZhmcAPI) DeleteNicReturns(result1 error) {
	fake.deleteNicMutex.Lock()
	defer fake.deleteNicMutex.Unlock()
	fake.DeleteNicStub = nil
	fake.deleteNicReturns = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) DeleteNicReturnsOnCall(i int, result1 error) {
	fake.deleteNicMutex.Lock()
	defer fake.deleteNicMutex.Unlock()
	fake.DeleteNicStub = nil
	if fake.deleteNicReturnsOnCall == nil {
		fake.deleteNicReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteNicReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) GetAdapters(arg1 string) []zhmcclient.Adapter {
	fake.getAdaptersMutex.Lock()
	ret, specificReturn := fake.getAdaptersReturnsOnCall[len(fake.getAdaptersArgsForCall)]
	fake.getAdaptersArgsForCall = append(fake.getAdaptersArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetAdaptersStub
	fakeReturns := fake.getAdaptersReturns
	fake.recordInvocation("GetAdapters", []interface{}{arg1})
	fake.getAdaptersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) GetAdaptersCallCount() int {
	fake.getAdaptersMutex.RLock()
	defer fake.getAdaptersMutex.RUnlock()
	return len(fake.getAdaptersArgsForCall)
}

func (fake *ZhmcAPI) GetAdaptersCalls(stub func(string) []zhmcclient.Adapter) {
	fake.getAdaptersMutex.Lock()
	defer fake.getAdaptersMutex.Unlock()
	fake.GetAdaptersStub = stub
}

func (fake *ZhmcAPI) GetAdaptersArgsForCall(i int) string {
	fake.getAdaptersMutex.RLock()
	defer fake.getAdaptersMutex.RUnlock()
	argsForCall := fake.getAdaptersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) GetAdaptersReturns(result1 []zhmcclient.Adapter) {
	fake.getAdaptersMutex.Lock()
	defer fake.getAdaptersMutex.Unlock()
	fake.GetAdaptersStub = nil
	fake.getAdaptersReturns = struct {
		result1 []zhmcclient.Adapter
	}{result1}
}

func (fake *ZhmcAPI) GetAdaptersReturnsOnCall(i int, result1 []zhmcclient.Adapter) {
	fake.getAdaptersMutex.Lock()
	defer fake.getAdaptersMutex.Unlock()
	fake.GetAdaptersStub = nil
	if fake.getAdaptersReturnsOnCall == nil {
		fake.getAdaptersReturnsOnCall = make(map[int]struct {
			result1 []zhmcclient.Adapter
		})
	}
	fake.getAdaptersReturnsOnCall[i] = struct {
		result1 []zhmcclient.Adapter
	}{result1}
}

func (fake *ZhmcAPI) GetCPCs() []zhmcclient.CPC {
	fake.getCPCsMutex.Lock()
	ret, specificReturn := fake.getCPCsReturnsOnCall[len(fake.getCPCsArgsForCall)]
	fake.getCPCsArgsForCall = append(fake.getCPCsArgsForCall, struct {
	}{})
	stub := fake.GetCPCsStub
	fakeReturns := fake.getCPCsReturns
	fake.recordInvocation("GetCPCs", []interface{}{})
	fake.getCPCsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) GetCPCsCallCount() int {
	fake.getCPCsMutex.RLock()
	defer fake.getCPCsMutex.RUnlock()
	return len(fake.getCPCsArgsForCall)
}

func (fake *ZhmcAPI) GetCPCsCalls(stub func() []zhmcclient.CPC) {
	fake.getCPCsMutex.Lock()
	defer fake.getCPCsMutex.Unlock()
	fake.GetCPCsStub = stub
}

func (fake *ZhmcAPI) GetCPCsReturns(result1 []zhmcclient.CPC) {
	fake.getCPCsMutex.Lock()
	defer fake.getCPCsMutex.Unlock()
	fake.GetCPCsStub = nil
	fake.getCPCsReturns = struct {
		result1 []zhmcclient.CPC
	}{result1}
}

func (fake *ZhmcAPI) GetCPCsReturnsOnCall(i int, result1 []zhmcclient.CPC) {
	fake.getCPCsMutex.Lock()
	defer fake.getCPCsMutex.Unlock()
	fake.GetCPCsStub = nil
	if fake.getCPCsReturnsOnCall == nil {
		fake.getCPCsReturnsOnCall = make(map[int]struct {
			result1 []zhmcclient.CPC
		})
	}
	fake.getCPCsReturnsOnCall[i] = struct {
		result1 []zhmcclient.CPC
	}{result1}
}

func (fake *ZhmcAPI) GetLPARs(arg1 string) []zhmcclient.LPAR {
	fake.getLPARsMutex.Lock()
	ret, specificReturn := fake.getLPARsReturnsOnCall[len(fake.getLPARsArgsForCall)]
	fake.getLPARsArgsForCall = append(fake.getLPARsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetLPARsStub
	fakeReturns := fake.getLPARsReturns
	fake.recordInvocation("GetLPARs", []interface{}{arg1})
	fake.getLPARsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) GetLPARsCallCount() int {
	fake.getLPARsMutex.RLock()
	defer fake.getLPARsMutex.RUnlock()
	return len(fake.getLPARsArgsForCall)
}

func (fake *ZhmcAPI) GetLPARsCalls(stub func(string) []zhmcclient.LPAR) {
	fake.getLPARsMutex.Lock()
	defer fake.getLPARsMutex.Unlock()
	fake.GetLPARsStub = stub
}

func (fake *ZhmcAPI) GetLPARsArgsForCall(i int) string {
	fake.getLPARsMutex.RLock()
	defer fake.getLPARsMutex.RUnlock()
	argsForCall := fake.getLPARsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) GetLPARsReturns(result1 []zhmcclient.LPAR) {
	fake.getLPARsMutex.Lock()
	defer fake.getLPARsMutex.Unlock()
	fake.GetLPARsStub = nil
	fake.getLPARsReturns = struct {
		result1 []zhmcclient.LPAR
	}{result1}
}

func (fake *ZhmcAPI) GetLPARsReturnsOnCall(i int, result1 []zhmcclient.LPAR) {
	fake.getLPARsMutex.Lock()
	defer fake.getLPARsMutex.Unlock()
	fake.GetLPARsStub = nil
	if fake.getLPARsReturnsOnCall == nil {
		fake.getLPARsReturnsOnCall = make(map[int]struct {
			result1 []zhmcclient.LPAR
		})
	}
	fake.getLPARsReturnsOnCall[i] = struct {
		result1 []zhmcclient.LPAR
	}{result1}
}

func (fake *ZhmcAPI) GetNic(arg1 string, arg2 string) (*zhmcclient.NIC, error) {
	fake.getNicMutex.Lock()
	ret, specificReturn := fake.getNicReturnsOnCall[len(fake.getNicArgsForCall)]
	fake.getNicArgsForCall = append(fake.getNicArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetNicStub
	fakeReturns := fake.getNicReturns
	fake.recordInvocation("GetNic", []interface{}{arg1, arg2})
	fake.getNicMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) GetNicCallCount() int {
	fake.getNicMutex.RLock()
	defer fake.getNicMutex.RUnlock()
	return len(fake.getNicArgsForCall)
}

func (fake *ZhmcAPI) GetNicCalls(stub func(string, string) (*zhmcclient.NIC, error)) {
	fake.getNicMutex.Lock()
	defer fake.getNicMutex.Unlock()
	fake.GetNicStub = stub
}

func (fake *ZhmcAPI) GetNicArgsForCall(i int) (string, string) {
	fake.getNicMutex.RLock()
	defer fake.getNicMutex.RUnlock()
	argsForCall := fake.getNicArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ZhmcAPI) GetNicReturns(result1 *zhmcclient.NIC, result2 error) {
	fake.getNicMutex.Lock()
	defer fake.getNicMutex.Unlock()
	fake.GetNicStub = nil
	fake.getNicReturns = struct {
		result1 *zhmcclient.NIC
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) GetNicReturnsOnCall(i int, result1 *zhmcclient.NIC, result2 error) {
	fake.getNicMutex.Lock()
	defer fake.getNicMutex.Unlock()
	fake.GetNicStub = nil
	if fake.getNicReturnsOnCall == nil {
		fake.getNicReturnsOnCall = make(map[int]struct {
			result1 *zhmcclient.NIC
			result2 error
		})
	}
	fake.getNicReturnsOnCall[i] = struct {
		result1 *zhmcclient.NIC
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) GetNics(arg1 string, arg2 string) []zhmcclient.NIC {
	fake.getNicsMutex.Lock()
	ret, specificReturn := fake.getNicsReturnsOnCall[len(fake.getNicsArgsForCall)]
	fake.getNicsArgsForCall = append(fake.getNicsArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetNicsStub
	fakeReturns := fake.getNicsReturns
	fake.recordInvocation("GetNics", []interface{}{arg1, arg2})
	fake.getNicsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) GetNicsCallCount() int {
	fake.getNicsMutex.RLock()
	defer fake.getNicsMutex.RUnlock()
	return len(fake.getNicsArgsForCall)
}

func (fake *ZhmcAPI) GetNicsCalls(stub func(string, string) []zhmcclient.NIC) {
	fake.getNicsMutex.Lock()
	defer fake.getNicsMutex.Unlock()
	fake.GetNicsStub = stub
}

func (fake *ZhmcAPI) GetNicsArgsForCall(i int) (string, string) {
	fake.getNicsMutex.RLock()
	defer fake.getNicsMutex.RUnlock()
	argsForCall := fake.getNicsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ZhmcAPI) GetNicsReturns(result1 []zhmcclient.NIC) {
	fake.getNicsMutex.Lock()
	defer fake.getNicsMutex.Unlock()
	fake.GetNicsStub = nil
	fake.getNicsReturns = struct {
		result1 []zhmcclient.NIC
	}{result1}
}

func (fake *ZhmcAPI) GetNicsReturnsOnCall(i int, result1 []zhmcclient.NIC) {
	fake.getNicsMutex.Lock()
	defer fake.getNicsMutex.Unlock()
	fake.GetNicsStub = nil
	if fake.getNicsReturnsOnCall == nil {
		fake.getNicsReturnsOnCall = make(map[int]struct {
			result1 []zhmcclient.NIC
		})
	}
	fake.getNicsReturnsOnCall[i] = struct {
		result1 []zhmcclient.NIC
	}{result1}
}

func (fake *ZhmcAPI) ListAdapters(arg1 string) ([]zhmcclient.Adapter, error) {
	fake.listAdaptersMutex.Lock()
	ret, specificReturn := fake.listAdaptersReturnsOnCall[len(fake.listAdaptersArgsForCall)]
	fake.listAdaptersArgsForCall = append(fake.listAdaptersArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListAdaptersStub
	fakeReturns := fake.listAdaptersReturns
	fake.recordInvocation("ListAdapters", []interface{}{arg1})
	fake.listAdaptersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) ListAdaptersCallCount() int {
	fake.listAdaptersMutex.RLock()
	defer fake.listAdaptersMutex.RUnlock()
	return len(fake.listAdaptersArgsForCall)
}

func (fake *ZhmcAPI) ListAdaptersCalls(stub func(string) ([]zhmcclient.Adapter, error)) {
	fake.listAdaptersMutex.Lock()
	defer fake.listAdaptersMutex.Unlock()
	fake.ListAdaptersStub = stub
}

func (fake *ZhmcAPI) ListAdaptersArgsForCall(i int) string {
	fake.listAdaptersMutex.RLock()
	defer fake.listAdaptersMutex.RUnlock()
	argsForCall := fake.listAdaptersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) ListAdaptersReturns(result1 []zhmcclient.Adapter, result2 error) {
	fake.listAdaptersMutex.Lock()
	defer fake.listAdaptersMutex.Unlock()
	fake.ListAdaptersStub = nil
	fake.listAdaptersReturns = struct {
		result1 []zhmcclient.Adapter
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListAdaptersReturnsOnCall(i int, result1 []zhmcclient.Adapter, result2 error) {
	fake.listAdaptersMutex.Lock()
	defer fake.listAdaptersMutex.Unlock()
	fake.ListAdaptersStub = nil
	if fake.listAdaptersReturnsOnCall == nil {
		fake.listAdaptersReturnsOnCall = make(map[int]struct {
			result1 []zhmcclient.Adapter
			result2 error
		})
	}
	fake.listAdaptersReturnsOnCall[i] = struct {
		result1 []zhmcclient.Adapter
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListCPCs() ([]zhmcclient.CPC, error) {
	fake.listCPCsMutex.Lock()
	ret, specificReturn := fake.listCPCsReturnsOnCall[len(fake.listCPCsArgsForCall)]
	fake.listCPCsArgsForCall = append(fake.listCPCsArgsForCall, struct {
	}{})
	stub := fake.ListCPCsStub
	fakeReturns := fake.listCPCsReturns
	fake.recordInvocation("ListCPCs", []interface{}{})
	fake.listCPCsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) ListCPCsCallCount() int {
	fake.listCPCsMutex.RLock()
	defer fake.listCPCsMutex.RUnlock()
	return len(fake.listCPCsArgsForCall)
}

func (fake *ZhmcAPI) ListCPCsCalls(stub func() ([]zhmcclient.CPC, error)) {
	fake.listCPCsMutex.Lock()
	defer fake.listCPCsMutex.Unlock()
	fake.ListCPCsStub = stub
}

func (fake *ZhmcAPI) ListCPCsReturns(result1 []zhmcclient.CPC, result2 error) {
	fake.listCPCsMutex.Lock()
	defer fake.listCPCsMutex.Unlock()
	fake.ListCPCsStub = nil
	fake.listCPCsReturns = struct {
		result1 []zhmcclient.CPC
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListCPCsReturnsOnCall(i int, result1 []zhmcclient.CPC, result2 error) {
	fake.listCPCsMutex.Lock()
	defer fake.listCPCsMutex.Unlock()
	fake.ListCPCsStub = nil
	if fake.listCPCsReturnsOnCall == nil {
		fake.listCPCsReturnsOnCall = make(map[int]struct {
			result1 []zhmcclient.CPC
			result2 error
		})
	}
	fake.listCPCsReturnsOnCall[i] = struct {
		result1 []zhmcclient.CPC
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListLPARs(arg1 string) ([]zhmcclient.LPAR, error) {
	fake.listLPARsMutex.Lock()
	ret, specificReturn := fake.listLPARsReturnsOnCall[len(fake.listLPARsArgsForCall)]
	fake.listLPARsArgsForCall = append(fake.listLPARsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListLPARsStub
	fakeReturns := fake.listLPARsReturns
	fake.recordInvocation("ListLPARs", []interface{}{arg1})
	fake.listLPARsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) ListLPARsCallCount() int {
	fake.listLPARsMutex.RLock()
	defer fake.listLPARsMutex.RUnlock()
	return len(fake.listLPARsArgsForCall)
}

func (fake *ZhmcAPI) ListLPARsCalls(stub func(string) ([]zhmcclient.LPAR, error)) {
	fake.listLPARsMutex.Lock()
	defer fake.listLPARsMutex.Unlock()
	fake.ListLPARsStub = stub
}

func (fake *ZhmcAPI) ListLPARsArgsForCall(i int) string {
	fake.listLPARsMutex.RLock()
	defer fake.listLPARsMutex.RUnlock()
	argsForCall := fake.listLPARsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) ListLPARsReturns(result1 []zhmcclient.LPAR, result2 error) {
	fake.listLPARsMutex.Lock()
	defer fake.listLPARsMutex.Unlock()
	fake.ListLPARsStub = nil
	fake.listLPARsReturns = struct {
		result1 []zhmcclient.LPAR
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListLPARsReturnsOnCall(i int, result1 []zhmcclient.LPAR, result2 error) {
	fake.listLPARsMutex.Lock()
	defer fake.listLPARsMutex.Unlock()
	fake.ListLPARsStub = nil
	if fake.listLPARsReturnsOnCall == nil {
		fake.listLPARsReturnsOnCall = make(map[int]struct {
			result1 []zhmcclient.LPAR
			result2 error
		})
	}
	fake.listLPARsReturnsOnCall[i] = struct {
		result1 []zhmcclient.LPAR
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListNics(arg1 string) ([]string, error) {
	fake.listNicsMutex.Lock()
	ret, specificReturn := fake.listNicsReturnsOnCall[len(fake.listNicsArgsForCall)]
	fake.listNicsArgsForCall = append(fake.listNicsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListNicsStub
	fakeReturns := fake.listNicsReturns
	fake.recordInvocation("ListNics", []interface{}{arg1})
	fake.listNicsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) ListNicsCallCount() int {
	fake.listNicsMutex.RLock()
	defer fake.listNicsMutex.RUnlock()
	return len(fake.listNicsArgsForCall)
}

func (fake *ZhmcAPI) ListNicsCalls(stub func(string) ([]string, error)) {
	fake.listNicsMutex.Lock()
	defer fake.listNicsMutex.Unlock()
	fake.ListNicsStub = stub
}

func (fake *ZhmcAPI) ListNicsArgsForCall(i int) string {
	fake.listNicsMutex.RLock()
	defer fake.listNicsMutex.RUnlock()
	argsForCall := fake.listNicsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) ListNicsReturns(result1 []string, result2 error) {
	fake.listNicsMutex.Lock()
	defer fake.listNicsMutex.Unlock()
	fake.ListNicsStub = nil
	fake.listNicsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListNicsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listNicsMutex.Lock()
	defer fake.listNicsMutex.Unlock()
	fake.ListNicsStub = nil
	if fake.listNicsReturnsOnCall == nil {
		fake.listNicsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listNicsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) MountIsoImage(arg1 string, arg2 string, arg3 string) error {
	fake.mountIsoImageMutex.Lock()
	ret, specificReturn := fake.mountIsoImageReturnsOnCall[len(fake.mountIsoImageArgsForCall)]
	fake.mountIsoImageArgsForCall = append(fake.mountIsoImageArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.MountIsoImageStub
	fakeReturns := fake.mountIsoImageReturns
	fake.recordInvocation("MountIsoImage", []interface{}{arg1, arg2, arg3})
	fake.mountIsoImageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) MountIsoImageCallCount() int {
	fake.mountIsoImageMutex.RLock()
	defer fake.mountIsoImageMutex.RUnlock()
	return len(fake.mountIsoImageArgsForCall)
}

func (fake *ZhmcAPI) MountIsoImageCalls(stub func(string, string, string) error) {
	fake.mountIsoImageMutex.Lock()
	defer fake.mountIsoImageMutex.Unlock()
	fake.MountIsoImageStub = stub
}

func (fake *ZhmcAPI) MountIsoImageArgsForCall(i int) (string, string, string) {
	fake.mountIsoImageMutex.RLock()
	defer fake.mountIsoImageMutex.RUnlock()
	argsForCall := fake.mountIsoImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *ZhmcAPI) MountIsoImageReturns(result1 error) {
	fake.mountIsoImageMutex.Lock()
	defer fake.mountIsoImageMutex.Unlock()
	fake.MountIsoImageStub = nil
	fake.mountIsoImageReturns = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) MountIsoImageReturnsOnCall(i int, result1 error) {
	fake.mountIsoImageMutex.Lock()
	defer fake.mountIsoImageMutex.Unlock()
	fake.MountIsoImageStub = nil
	if fake.mountIsoImageReturnsOnCall == nil {
		fake.mountIsoImageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mountIsoImageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) QueryJob(arg1 string) (*zhmcclient.Job, error) {
	fake.queryJobMutex.Lock()
	ret, specificReturn := fake.queryJobReturnsOnCall[len(fake.queryJobArgsForCall)]
	fake.queryJobArgsForCall = append(fake.queryJobArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.QueryJobStub
	fakeReturns := fake.queryJobReturns
	fake.recordInvocation("QueryJob", []interface{}{arg1})
	fake.queryJobMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) QueryJobCallCount() int {
	fake.queryJobMutex.RLock()
	defer fake.queryJobMutex.RUnlock()
	return len(fake.queryJobArgsForCall)
}

func (fake *ZhmcAPI) QueryJobCalls(stub func(string) (*zhmcclient.Job, error)) {
	fake.queryJobMutex.Lock()
	defer fake.queryJobMutex.Unlock()
	fake.QueryJobStub = stub
}

func (fake *ZhmcAPI) QueryJobArgsForCall(i int) string {
	fake.queryJobMutex.RLock()
	defer fake.queryJobMutex.RUnlock()
	argsForCall := fake.queryJobArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) QueryJobReturns(result1 *zhmcclient.Job, result2 error) {
	fake.queryJobMutex.Lock()
	defer fake.queryJobMutex.Unlock()
	fake.QueryJobStub = nil
	fake.queryJobReturns = struct {
		result1 *zhmcclient.Job
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) QueryJobReturnsOnCall(i int, result1 *zhmcclient.Job, result2 error) {
	fake.queryJobMutex.Lock()
	defer fake.queryJobMutex.Unlock()
	fake.QueryJobStub = nil
	if fake.queryJobReturnsOnCall == nil {
		fake.queryJobReturnsOnCall = make(map[int]struct {
			result1 *zhmcclient.Job
			result2 error
		})
	}
	fake.queryJobReturnsOnCall[i] = struct {
		result1 *zhmcclient.Job
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) StartLPAR(arg1 string) (string, error) {
	fake.startLPARMutex.Lock()
	ret, specificReturn := fake.startLPARReturnsOnCall[len(fake.startLPARArgsForCall)]
	fake.startLPARArgsForCall = append(fake.startLPARArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StartLPARStub
	fakeReturns := fake.startLPARReturns
	fake.recordInvocation("StartLPAR", []interface{}{arg1})
	fake.startLPARMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) StartLPARCallCount() int {
	fake.startLPARMutex.RLock()
	defer fake.startLPARMutex.RUnlock()
	return len(fake.startLPARArgsForCall)
}

func (fake *ZhmcAPI) StartLPARCalls(stub func(string) (string, error)) {
	fake.startLPARMutex.Lock()
	defer fake.startLPARMutex.Unlock()
	fake.StartLPARStub = stub
}

func (fake *ZhmcAPI) StartLPARArgsForCall(i int) string {
	fake.startLPARMutex.RLock()
	defer fake.startLPARMutex.RUnlock()
	argsForCall := fake.startLPARArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) StartLPARReturns(result1 string, result2 error) {
	fake.startLPARMutex.Lock()
	defer fake.startLPARMutex.Unlock()
	fake.StartLPARStub = nil
	fake.startLPARReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) StartLPARReturnsOnCall(i int, result1 string, result2 error) {
	fake.startLPARMutex.Lock()
	defer fake.startLPARMutex.Unlock()
	fake.StartLPARStub = nil
	if fake.startLPARReturnsOnCall == nil {
		fake.startLPARReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.startLPARReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) StopLPAR(arg1 string) (string, error) {
	fake.stopLPARMutex.Lock()
	ret, specificReturn := fake.stopLPARReturnsOnCall[len(fake.stopLPARArgsForCall)]
	fake.stopLPARArgsForCall = append(fake.stopLPARArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StopLPARStub
	fakeReturns := fake.stopLPARReturns
	fake.recordInvocation("StopLPAR", []interface{}{arg1})
	fake.stopLPARMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) StopLPARCallCount() int {
	fake.stopLPARMutex.RLock()
	defer fake.stopLPARMutex.RUnlock()
	return len(fake.stopLPARArgsForCall)
}

func (fake *ZhmcAPI) StopLPARCalls(stub func(string) (string, error)) {
	fake.stopLPARMutex.Lock()
	defer fake.stopLPARMutex.Unlock()
	fake.StopLPARStub = stub
}

func (fake *ZhmcAPI) StopLPARArgsForCall(i int) string {
	fake.stopLPARMutex.RLock()
	defer fake.stopLPARMutex.RUnlock()
	argsForCall := fake.stopLPARArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) StopLPARReturns(result1 string, result2 error) {
	fake.stopLPARMutex.Lock()
	defer fake.stopLPARMutex.Unlock()
	fake.StopLPARStub = nil
	fake.stopLPARReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) StopLPARReturnsOnCall(i int, result1 string, result2 error) {
	fake.stopLPARMutex.Lock()
	defer fake.stopLPARMutex.Unlock()
	fake.StopLPARStub = nil
	if fake.stopLPARReturnsOnCall == nil {
		fake.stopLPARReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.stopLPARReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) UpdateLparProperties(arg1 string, arg2 map[string]string) (*zhmcclient.LPAR, error) {
	fake.updateLparPropertiesMutex.Lock()
	ret, specificReturn := fake.updateLparPropertiesReturnsOnCall[len(fake.updateLparPropertiesArgsForCall)]
	fake.updateLparPropertiesArgsForCall = append(fake.updateLparPropertiesArgsForCall, struct {
		arg1 string
		arg2 map[string]string
	}{arg1, arg2})
	stub := fake.UpdateLparPropertiesStub
	fakeReturns := fake.updateLparPropertiesReturns
	fake.recordInvocation("UpdateLparProperties", []interface{}{arg1, arg2})
	fake.updateLparPropertiesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) UpdateLparPropertiesCallCount() int {
	fake.updateLparPropertiesMutex.RLock()
	defer fake.updateLparPropertiesMutex.RUnlock()
	return len(fake.updateLparPropertiesArgsForCall)
}

func (fake *ZhmcAPI) UpdateLparPropertiesCalls(stub func(string, map[string]string) (*zhmcclient.LPAR, error)) {
	fake.updateLparPropertiesMutex.Lock()
	defer fake.updateLparPropertiesMutex.Unlock()
	fake.UpdateLparPropertiesStub = stub
}

func (fake *ZhmcAPI) UpdateLparPropertiesArgsForCall(i int) (string, map[string]string) {
	fake.updateLparPropertiesMutex.RLock()
	defer fake.updateLparPropertiesMutex.RUnlock()
	argsForCall := fake.updateLparPropertiesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ZhmcAPI) UpdateLparPropertiesReturns(result1 *zhmcclient.LPAR, result2 error) {
	fake.updateLparPropertiesMutex.Lock()
	defer fake.updateLparPropertiesMutex.Unlock()
	fake.UpdateLparPropertiesStub = nil
	fake.updateLparPropertiesReturns = struct {
		result1 *zhmcclient.LPAR
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) UpdateLparPropertiesReturnsOnCall(i int, result1 *zhmcclient.LPAR, result2 error) {
	fake.updateLparPropertiesMutex.Lock()
	defer fake.updateLparPropertiesMutex.Unlock()
	fake.UpdateLparPropertiesStub = nil
	if fake.updateLparPropertiesReturnsOnCall == nil {
		fake.updateLparPropertiesReturnsOnCall = make(map[int]struct {
			result1 *zhmcclient.LPAR
			result2 error
		})
	}
	fake.updateLparPropertiesReturnsOnCall[i] = struct {
		result1 *zhmcclient.LPAR
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createAdapterMutex.RLock()
	defer fake.createAdapterMutex.RUnlock()
	fake.createNicMutex.RLock()
	defer fake.createNicMutex.RUnlock()
	fake.deleteAdapterMutex.RLock()
	defer fake.deleteAdapterMutex.RUnlock()
	fake.deleteJobMutex.RLock()
	defer fake.deleteJobMutex.RUnlock()
	fake.deleteNicMutex.RLock()
	defer fake.deleteNicMutex.RUnlock()
	fake.getAdaptersMutex.RLock()
	defer fake.getAdaptersMutex.RUnlock()
	fake.getCPCsMutex.RLock()
	defer fake.getCPCsMutex.RUnlock()
	fake.getLPARsMutex.RLock()
	defer fake.getLPARsMutex.RUnlock()
	fake.getNicMutex.RLock()
	defer fake.getNicMutex.RUnlock()
	fake.getNicsMutex.RLock()
	defer fake.getNicsMutex.RUnlock()
	fake.listAdaptersMutex.RLock()
	defer fake.listAdaptersMutex.RUnlock()
	fake.listCPCsMutex.RLock()
	defer fake.listCPCsMutex.RUnlock()
	fake.listLPARsMutex.RLock()
	defer fake.listLPARsMutex.RUnlock()
	fake.listNicsMutex.RLock()
	defer fake.listNicsMutex.RUnlock()
	fake.mountIsoImageMutex.RLock()
	defer fake.mountIsoImageMutex.RUnlock()
	fake.queryJobMutex.RLock()
	defer fake.queryJobMutex.RUnlock()
	fake.startLPARMutex.RLock()
	defer fake.startLPARMutex.RUnlock()
	fake.stopLPARMutex.RLock()
	defer fake.stopLPARMutex.RUnlock()
	fake.updateLparPropertiesMutex.RLock()
	defer fake.updateLparPropertiesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ZhmcAPI) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ zhmcclient.ZhmcAPI = new(ZhmcAPI)
