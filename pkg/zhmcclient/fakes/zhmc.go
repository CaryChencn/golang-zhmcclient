// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"github.ibm.com/zhmcclient/golang-zhmcclient/pkg/zhmcclient"
)

type ZhmcAPI struct {
	CancelJobStub        func(string) error
	cancelJobMutex       sync.RWMutex
	cancelJobArgsForCall []struct {
		arg1 string
	}
	cancelJobReturns struct {
		result1 error
	}
	cancelJobReturnsOnCall map[int]struct {
		result1 error
	}
	CreateHipersocketStub        func(string, *zhmcclient.HypersocketPayload) (string, error)
	createHipersocketMutex       sync.RWMutex
	createHipersocketArgsForCall []struct {
		arg1 string
		arg2 *zhmcclient.HypersocketPayload
	}
	createHipersocketReturns struct {
		result1 string
		result2 error
	}
	createHipersocketReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CreateNicStub        func(string, *zhmcclient.NIC) (string, error)
	createNicMutex       sync.RWMutex
	createNicArgsForCall []struct {
		arg1 string
		arg2 *zhmcclient.NIC
	}
	createNicReturns struct {
		result1 string
		result2 error
	}
	createNicReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	DeleteHipersocketStub        func(string) error
	deleteHipersocketMutex       sync.RWMutex
	deleteHipersocketArgsForCall []struct {
		arg1 string
	}
	deleteHipersocketReturns struct {
		result1 error
	}
	deleteHipersocketReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteJobStub        func(string) error
	deleteJobMutex       sync.RWMutex
	deleteJobArgsForCall []struct {
		arg1 string
	}
	deleteJobReturns struct {
		result1 error
	}
	deleteJobReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteNicStub        func(string) error
	deleteNicMutex       sync.RWMutex
	deleteNicArgsForCall []struct {
		arg1 string
	}
	deleteNicReturns struct {
		result1 error
	}
	deleteNicReturnsOnCall map[int]struct {
		result1 error
	}
	GetLparPropertiesStub        func(string) (*zhmcclient.LparProperties, error)
	getLparPropertiesMutex       sync.RWMutex
	getLparPropertiesArgsForCall []struct {
		arg1 string
	}
	getLparPropertiesReturns struct {
		result1 *zhmcclient.LparProperties
		result2 error
	}
	getLparPropertiesReturnsOnCall map[int]struct {
		result1 *zhmcclient.LparProperties
		result2 error
	}
	GetNicPropertiesStub        func(string) (*zhmcclient.NIC, error)
	getNicPropertiesMutex       sync.RWMutex
	getNicPropertiesArgsForCall []struct {
		arg1 string
	}
	getNicPropertiesReturns struct {
		result1 *zhmcclient.NIC
		result2 error
	}
	getNicPropertiesReturnsOnCall map[int]struct {
		result1 *zhmcclient.NIC
		result2 error
	}
	ListAdaptersStub        func(string, map[string]string) ([]zhmcclient.Adapter, error)
	listAdaptersMutex       sync.RWMutex
	listAdaptersArgsForCall []struct {
		arg1 string
		arg2 map[string]string
	}
	listAdaptersReturns struct {
		result1 []zhmcclient.Adapter
		result2 error
	}
	listAdaptersReturnsOnCall map[int]struct {
		result1 []zhmcclient.Adapter
		result2 error
	}
	ListCPCsStub        func(map[string]string) ([]zhmcclient.CPC, error)
	listCPCsMutex       sync.RWMutex
	listCPCsArgsForCall []struct {
		arg1 map[string]string
	}
	listCPCsReturns struct {
		result1 []zhmcclient.CPC
		result2 error
	}
	listCPCsReturnsOnCall map[int]struct {
		result1 []zhmcclient.CPC
		result2 error
	}
	ListLPARsStub        func(string, map[string]string) ([]zhmcclient.LPAR, error)
	listLPARsMutex       sync.RWMutex
	listLPARsArgsForCall []struct {
		arg1 string
		arg2 map[string]string
	}
	listLPARsReturns struct {
		result1 []zhmcclient.LPAR
		result2 error
	}
	listLPARsReturnsOnCall map[int]struct {
		result1 []zhmcclient.LPAR
		result2 error
	}
	ListNicsStub        func(string) ([]string, error)
	listNicsMutex       sync.RWMutex
	listNicsArgsForCall []struct {
		arg1 string
	}
	listNicsReturns struct {
		result1 []string
		result2 error
	}
	listNicsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	MountIsoImageStub        func(string, string, string) error
	mountIsoImageMutex       sync.RWMutex
	mountIsoImageArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	mountIsoImageReturns struct {
		result1 error
	}
	mountIsoImageReturnsOnCall map[int]struct {
		result1 error
	}
	QueryJobStub        func(string) (*zhmcclient.Job, error)
	queryJobMutex       sync.RWMutex
	queryJobArgsForCall []struct {
		arg1 string
	}
	queryJobReturns struct {
		result1 *zhmcclient.Job
		result2 error
	}
	queryJobReturnsOnCall map[int]struct {
		result1 *zhmcclient.Job
		result2 error
	}
	StartLPARStub        func(string) (string, error)
	startLPARMutex       sync.RWMutex
	startLPARArgsForCall []struct {
		arg1 string
	}
	startLPARReturns struct {
		result1 string
		result2 error
	}
	startLPARReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	StopLPARStub        func(string) (string, error)
	stopLPARMutex       sync.RWMutex
	stopLPARArgsForCall []struct {
		arg1 string
	}
	stopLPARReturns struct {
		result1 string
		result2 error
	}
	stopLPARReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	UnmountIsoImageStub        func(string) error
	unmountIsoImageMutex       sync.RWMutex
	unmountIsoImageArgsForCall []struct {
		arg1 string
	}
	unmountIsoImageReturns struct {
		result1 error
	}
	unmountIsoImageReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateLparPropertiesStub        func(string, *zhmcclient.LparProperties) error
	updateLparPropertiesMutex       sync.RWMutex
	updateLparPropertiesArgsForCall []struct {
		arg1 string
		arg2 *zhmcclient.LparProperties
	}
	updateLparPropertiesReturns struct {
		result1 error
	}
	updateLparPropertiesReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ZhmcAPI) CancelJob(arg1 string) error {
	fake.cancelJobMutex.Lock()
	ret, specificReturn := fake.cancelJobReturnsOnCall[len(fake.cancelJobArgsForCall)]
	fake.cancelJobArgsForCall = append(fake.cancelJobArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CancelJobStub
	fakeReturns := fake.cancelJobReturns
	fake.recordInvocation("CancelJob", []interface{}{arg1})
	fake.cancelJobMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) CancelJobCallCount() int {
	fake.cancelJobMutex.RLock()
	defer fake.cancelJobMutex.RUnlock()
	return len(fake.cancelJobArgsForCall)
}

func (fake *ZhmcAPI) CancelJobCalls(stub func(string) error) {
	fake.cancelJobMutex.Lock()
	defer fake.cancelJobMutex.Unlock()
	fake.CancelJobStub = stub
}

func (fake *ZhmcAPI) CancelJobArgsForCall(i int) string {
	fake.cancelJobMutex.RLock()
	defer fake.cancelJobMutex.RUnlock()
	argsForCall := fake.cancelJobArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) CancelJobReturns(result1 error) {
	fake.cancelJobMutex.Lock()
	defer fake.cancelJobMutex.Unlock()
	fake.CancelJobStub = nil
	fake.cancelJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) CancelJobReturnsOnCall(i int, result1 error) {
	fake.cancelJobMutex.Lock()
	defer fake.cancelJobMutex.Unlock()
	fake.CancelJobStub = nil
	if fake.cancelJobReturnsOnCall == nil {
		fake.cancelJobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelJobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) CreateHipersocket(arg1 string, arg2 *zhmcclient.HypersocketPayload) (string, error) {
	fake.createHipersocketMutex.Lock()
	ret, specificReturn := fake.createHipersocketReturnsOnCall[len(fake.createHipersocketArgsForCall)]
	fake.createHipersocketArgsForCall = append(fake.createHipersocketArgsForCall, struct {
		arg1 string
		arg2 *zhmcclient.HypersocketPayload
	}{arg1, arg2})
	stub := fake.CreateHipersocketStub
	fakeReturns := fake.createHipersocketReturns
	fake.recordInvocation("CreateHipersocket", []interface{}{arg1, arg2})
	fake.createHipersocketMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) CreateHipersocketCallCount() int {
	fake.createHipersocketMutex.RLock()
	defer fake.createHipersocketMutex.RUnlock()
	return len(fake.createHipersocketArgsForCall)
}

func (fake *ZhmcAPI) CreateHipersocketCalls(stub func(string, *zhmcclient.HypersocketPayload) (string, error)) {
	fake.createHipersocketMutex.Lock()
	defer fake.createHipersocketMutex.Unlock()
	fake.CreateHipersocketStub = stub
}

func (fake *ZhmcAPI) CreateHipersocketArgsForCall(i int) (string, *zhmcclient.HypersocketPayload) {
	fake.createHipersocketMutex.RLock()
	defer fake.createHipersocketMutex.RUnlock()
	argsForCall := fake.createHipersocketArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ZhmcAPI) CreateHipersocketReturns(result1 string, result2 error) {
	fake.createHipersocketMutex.Lock()
	defer fake.createHipersocketMutex.Unlock()
	fake.CreateHipersocketStub = nil
	fake.createHipersocketReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) CreateHipersocketReturnsOnCall(i int, result1 string, result2 error) {
	fake.createHipersocketMutex.Lock()
	defer fake.createHipersocketMutex.Unlock()
	fake.CreateHipersocketStub = nil
	if fake.createHipersocketReturnsOnCall == nil {
		fake.createHipersocketReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createHipersocketReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) CreateNic(arg1 string, arg2 *zhmcclient.NIC) (string, error) {
	fake.createNicMutex.Lock()
	ret, specificReturn := fake.createNicReturnsOnCall[len(fake.createNicArgsForCall)]
	fake.createNicArgsForCall = append(fake.createNicArgsForCall, struct {
		arg1 string
		arg2 *zhmcclient.NIC
	}{arg1, arg2})
	stub := fake.CreateNicStub
	fakeReturns := fake.createNicReturns
	fake.recordInvocation("CreateNic", []interface{}{arg1, arg2})
	fake.createNicMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) CreateNicCallCount() int {
	fake.createNicMutex.RLock()
	defer fake.createNicMutex.RUnlock()
	return len(fake.createNicArgsForCall)
}

func (fake *ZhmcAPI) CreateNicCalls(stub func(string, *zhmcclient.NIC) (string, error)) {
	fake.createNicMutex.Lock()
	defer fake.createNicMutex.Unlock()
	fake.CreateNicStub = stub
}

func (fake *ZhmcAPI) CreateNicArgsForCall(i int) (string, *zhmcclient.NIC) {
	fake.createNicMutex.RLock()
	defer fake.createNicMutex.RUnlock()
	argsForCall := fake.createNicArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ZhmcAPI) CreateNicReturns(result1 string, result2 error) {
	fake.createNicMutex.Lock()
	defer fake.createNicMutex.Unlock()
	fake.CreateNicStub = nil
	fake.createNicReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) CreateNicReturnsOnCall(i int, result1 string, result2 error) {
	fake.createNicMutex.Lock()
	defer fake.createNicMutex.Unlock()
	fake.CreateNicStub = nil
	if fake.createNicReturnsOnCall == nil {
		fake.createNicReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createNicReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) DeleteHipersocket(arg1 string) error {
	fake.deleteHipersocketMutex.Lock()
	ret, specificReturn := fake.deleteHipersocketReturnsOnCall[len(fake.deleteHipersocketArgsForCall)]
	fake.deleteHipersocketArgsForCall = append(fake.deleteHipersocketArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteHipersocketStub
	fakeReturns := fake.deleteHipersocketReturns
	fake.recordInvocation("DeleteHipersocket", []interface{}{arg1})
	fake.deleteHipersocketMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) DeleteHipersocketCallCount() int {
	fake.deleteHipersocketMutex.RLock()
	defer fake.deleteHipersocketMutex.RUnlock()
	return len(fake.deleteHipersocketArgsForCall)
}

func (fake *ZhmcAPI) DeleteHipersocketCalls(stub func(string) error) {
	fake.deleteHipersocketMutex.Lock()
	defer fake.deleteHipersocketMutex.Unlock()
	fake.DeleteHipersocketStub = stub
}

func (fake *ZhmcAPI) DeleteHipersocketArgsForCall(i int) string {
	fake.deleteHipersocketMutex.RLock()
	defer fake.deleteHipersocketMutex.RUnlock()
	argsForCall := fake.deleteHipersocketArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) DeleteHipersocketReturns(result1 error) {
	fake.deleteHipersocketMutex.Lock()
	defer fake.deleteHipersocketMutex.Unlock()
	fake.DeleteHipersocketStub = nil
	fake.deleteHipersocketReturns = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) DeleteHipersocketReturnsOnCall(i int, result1 error) {
	fake.deleteHipersocketMutex.Lock()
	defer fake.deleteHipersocketMutex.Unlock()
	fake.DeleteHipersocketStub = nil
	if fake.deleteHipersocketReturnsOnCall == nil {
		fake.deleteHipersocketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteHipersocketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) DeleteJob(arg1 string) error {
	fake.deleteJobMutex.Lock()
	ret, specificReturn := fake.deleteJobReturnsOnCall[len(fake.deleteJobArgsForCall)]
	fake.deleteJobArgsForCall = append(fake.deleteJobArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteJobStub
	fakeReturns := fake.deleteJobReturns
	fake.recordInvocation("DeleteJob", []interface{}{arg1})
	fake.deleteJobMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) DeleteJobCallCount() int {
	fake.deleteJobMutex.RLock()
	defer fake.deleteJobMutex.RUnlock()
	return len(fake.deleteJobArgsForCall)
}

func (fake *ZhmcAPI) DeleteJobCalls(stub func(string) error) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = stub
}

func (fake *ZhmcAPI) DeleteJobArgsForCall(i int) string {
	fake.deleteJobMutex.RLock()
	defer fake.deleteJobMutex.RUnlock()
	argsForCall := fake.deleteJobArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) DeleteJobReturns(result1 error) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = nil
	fake.deleteJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) DeleteJobReturnsOnCall(i int, result1 error) {
	fake.deleteJobMutex.Lock()
	defer fake.deleteJobMutex.Unlock()
	fake.DeleteJobStub = nil
	if fake.deleteJobReturnsOnCall == nil {
		fake.deleteJobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteJobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) DeleteNic(arg1 string) error {
	fake.deleteNicMutex.Lock()
	ret, specificReturn := fake.deleteNicReturnsOnCall[len(fake.deleteNicArgsForCall)]
	fake.deleteNicArgsForCall = append(fake.deleteNicArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteNicStub
	fakeReturns := fake.deleteNicReturns
	fake.recordInvocation("DeleteNic", []interface{}{arg1})
	fake.deleteNicMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) DeleteNicCallCount() int {
	fake.deleteNicMutex.RLock()
	defer fake.deleteNicMutex.RUnlock()
	return len(fake.deleteNicArgsForCall)
}

func (fake *ZhmcAPI) DeleteNicCalls(stub func(string) error) {
	fake.deleteNicMutex.Lock()
	defer fake.deleteNicMutex.Unlock()
	fake.DeleteNicStub = stub
}

func (fake *ZhmcAPI) DeleteNicArgsForCall(i int) string {
	fake.deleteNicMutex.RLock()
	defer fake.deleteNicMutex.RUnlock()
	argsForCall := fake.deleteNicArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) DeleteNicReturns(result1 error) {
	fake.deleteNicMutex.Lock()
	defer fake.deleteNicMutex.Unlock()
	fake.DeleteNicStub = nil
	fake.deleteNicReturns = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) DeleteNicReturnsOnCall(i int, result1 error) {
	fake.deleteNicMutex.Lock()
	defer fake.deleteNicMutex.Unlock()
	fake.DeleteNicStub = nil
	if fake.deleteNicReturnsOnCall == nil {
		fake.deleteNicReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteNicReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) GetLparProperties(arg1 string) (*zhmcclient.LparProperties, error) {
	fake.getLparPropertiesMutex.Lock()
	ret, specificReturn := fake.getLparPropertiesReturnsOnCall[len(fake.getLparPropertiesArgsForCall)]
	fake.getLparPropertiesArgsForCall = append(fake.getLparPropertiesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetLparPropertiesStub
	fakeReturns := fake.getLparPropertiesReturns
	fake.recordInvocation("GetLparProperties", []interface{}{arg1})
	fake.getLparPropertiesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) GetLparPropertiesCallCount() int {
	fake.getLparPropertiesMutex.RLock()
	defer fake.getLparPropertiesMutex.RUnlock()
	return len(fake.getLparPropertiesArgsForCall)
}

func (fake *ZhmcAPI) GetLparPropertiesCalls(stub func(string) (*zhmcclient.LparProperties, error)) {
	fake.getLparPropertiesMutex.Lock()
	defer fake.getLparPropertiesMutex.Unlock()
	fake.GetLparPropertiesStub = stub
}

func (fake *ZhmcAPI) GetLparPropertiesArgsForCall(i int) string {
	fake.getLparPropertiesMutex.RLock()
	defer fake.getLparPropertiesMutex.RUnlock()
	argsForCall := fake.getLparPropertiesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) GetLparPropertiesReturns(result1 *zhmcclient.LparProperties, result2 error) {
	fake.getLparPropertiesMutex.Lock()
	defer fake.getLparPropertiesMutex.Unlock()
	fake.GetLparPropertiesStub = nil
	fake.getLparPropertiesReturns = struct {
		result1 *zhmcclient.LparProperties
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) GetLparPropertiesReturnsOnCall(i int, result1 *zhmcclient.LparProperties, result2 error) {
	fake.getLparPropertiesMutex.Lock()
	defer fake.getLparPropertiesMutex.Unlock()
	fake.GetLparPropertiesStub = nil
	if fake.getLparPropertiesReturnsOnCall == nil {
		fake.getLparPropertiesReturnsOnCall = make(map[int]struct {
			result1 *zhmcclient.LparProperties
			result2 error
		})
	}
	fake.getLparPropertiesReturnsOnCall[i] = struct {
		result1 *zhmcclient.LparProperties
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) GetNicProperties(arg1 string) (*zhmcclient.NIC, error) {
	fake.getNicPropertiesMutex.Lock()
	ret, specificReturn := fake.getNicPropertiesReturnsOnCall[len(fake.getNicPropertiesArgsForCall)]
	fake.getNicPropertiesArgsForCall = append(fake.getNicPropertiesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetNicPropertiesStub
	fakeReturns := fake.getNicPropertiesReturns
	fake.recordInvocation("GetNicProperties", []interface{}{arg1})
	fake.getNicPropertiesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) GetNicPropertiesCallCount() int {
	fake.getNicPropertiesMutex.RLock()
	defer fake.getNicPropertiesMutex.RUnlock()
	return len(fake.getNicPropertiesArgsForCall)
}

func (fake *ZhmcAPI) GetNicPropertiesCalls(stub func(string) (*zhmcclient.NIC, error)) {
	fake.getNicPropertiesMutex.Lock()
	defer fake.getNicPropertiesMutex.Unlock()
	fake.GetNicPropertiesStub = stub
}

func (fake *ZhmcAPI) GetNicPropertiesArgsForCall(i int) string {
	fake.getNicPropertiesMutex.RLock()
	defer fake.getNicPropertiesMutex.RUnlock()
	argsForCall := fake.getNicPropertiesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) GetNicPropertiesReturns(result1 *zhmcclient.NIC, result2 error) {
	fake.getNicPropertiesMutex.Lock()
	defer fake.getNicPropertiesMutex.Unlock()
	fake.GetNicPropertiesStub = nil
	fake.getNicPropertiesReturns = struct {
		result1 *zhmcclient.NIC
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) GetNicPropertiesReturnsOnCall(i int, result1 *zhmcclient.NIC, result2 error) {
	fake.getNicPropertiesMutex.Lock()
	defer fake.getNicPropertiesMutex.Unlock()
	fake.GetNicPropertiesStub = nil
	if fake.getNicPropertiesReturnsOnCall == nil {
		fake.getNicPropertiesReturnsOnCall = make(map[int]struct {
			result1 *zhmcclient.NIC
			result2 error
		})
	}
	fake.getNicPropertiesReturnsOnCall[i] = struct {
		result1 *zhmcclient.NIC
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListAdapters(arg1 string, arg2 map[string]string) ([]zhmcclient.Adapter, error) {
	fake.listAdaptersMutex.Lock()
	ret, specificReturn := fake.listAdaptersReturnsOnCall[len(fake.listAdaptersArgsForCall)]
	fake.listAdaptersArgsForCall = append(fake.listAdaptersArgsForCall, struct {
		arg1 string
		arg2 map[string]string
	}{arg1, arg2})
	stub := fake.ListAdaptersStub
	fakeReturns := fake.listAdaptersReturns
	fake.recordInvocation("ListAdapters", []interface{}{arg1, arg2})
	fake.listAdaptersMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) ListAdaptersCallCount() int {
	fake.listAdaptersMutex.RLock()
	defer fake.listAdaptersMutex.RUnlock()
	return len(fake.listAdaptersArgsForCall)
}

func (fake *ZhmcAPI) ListAdaptersCalls(stub func(string, map[string]string) ([]zhmcclient.Adapter, error)) {
	fake.listAdaptersMutex.Lock()
	defer fake.listAdaptersMutex.Unlock()
	fake.ListAdaptersStub = stub
}

func (fake *ZhmcAPI) ListAdaptersArgsForCall(i int) (string, map[string]string) {
	fake.listAdaptersMutex.RLock()
	defer fake.listAdaptersMutex.RUnlock()
	argsForCall := fake.listAdaptersArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ZhmcAPI) ListAdaptersReturns(result1 []zhmcclient.Adapter, result2 error) {
	fake.listAdaptersMutex.Lock()
	defer fake.listAdaptersMutex.Unlock()
	fake.ListAdaptersStub = nil
	fake.listAdaptersReturns = struct {
		result1 []zhmcclient.Adapter
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListAdaptersReturnsOnCall(i int, result1 []zhmcclient.Adapter, result2 error) {
	fake.listAdaptersMutex.Lock()
	defer fake.listAdaptersMutex.Unlock()
	fake.ListAdaptersStub = nil
	if fake.listAdaptersReturnsOnCall == nil {
		fake.listAdaptersReturnsOnCall = make(map[int]struct {
			result1 []zhmcclient.Adapter
			result2 error
		})
	}
	fake.listAdaptersReturnsOnCall[i] = struct {
		result1 []zhmcclient.Adapter
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListCPCs(arg1 map[string]string) ([]zhmcclient.CPC, error) {
	fake.listCPCsMutex.Lock()
	ret, specificReturn := fake.listCPCsReturnsOnCall[len(fake.listCPCsArgsForCall)]
	fake.listCPCsArgsForCall = append(fake.listCPCsArgsForCall, struct {
		arg1 map[string]string
	}{arg1})
	stub := fake.ListCPCsStub
	fakeReturns := fake.listCPCsReturns
	fake.recordInvocation("ListCPCs", []interface{}{arg1})
	fake.listCPCsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) ListCPCsCallCount() int {
	fake.listCPCsMutex.RLock()
	defer fake.listCPCsMutex.RUnlock()
	return len(fake.listCPCsArgsForCall)
}

func (fake *ZhmcAPI) ListCPCsCalls(stub func(map[string]string) ([]zhmcclient.CPC, error)) {
	fake.listCPCsMutex.Lock()
	defer fake.listCPCsMutex.Unlock()
	fake.ListCPCsStub = stub
}

func (fake *ZhmcAPI) ListCPCsArgsForCall(i int) map[string]string {
	fake.listCPCsMutex.RLock()
	defer fake.listCPCsMutex.RUnlock()
	argsForCall := fake.listCPCsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) ListCPCsReturns(result1 []zhmcclient.CPC, result2 error) {
	fake.listCPCsMutex.Lock()
	defer fake.listCPCsMutex.Unlock()
	fake.ListCPCsStub = nil
	fake.listCPCsReturns = struct {
		result1 []zhmcclient.CPC
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListCPCsReturnsOnCall(i int, result1 []zhmcclient.CPC, result2 error) {
	fake.listCPCsMutex.Lock()
	defer fake.listCPCsMutex.Unlock()
	fake.ListCPCsStub = nil
	if fake.listCPCsReturnsOnCall == nil {
		fake.listCPCsReturnsOnCall = make(map[int]struct {
			result1 []zhmcclient.CPC
			result2 error
		})
	}
	fake.listCPCsReturnsOnCall[i] = struct {
		result1 []zhmcclient.CPC
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListLPARs(arg1 string, arg2 map[string]string) ([]zhmcclient.LPAR, error) {
	fake.listLPARsMutex.Lock()
	ret, specificReturn := fake.listLPARsReturnsOnCall[len(fake.listLPARsArgsForCall)]
	fake.listLPARsArgsForCall = append(fake.listLPARsArgsForCall, struct {
		arg1 string
		arg2 map[string]string
	}{arg1, arg2})
	stub := fake.ListLPARsStub
	fakeReturns := fake.listLPARsReturns
	fake.recordInvocation("ListLPARs", []interface{}{arg1, arg2})
	fake.listLPARsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) ListLPARsCallCount() int {
	fake.listLPARsMutex.RLock()
	defer fake.listLPARsMutex.RUnlock()
	return len(fake.listLPARsArgsForCall)
}

func (fake *ZhmcAPI) ListLPARsCalls(stub func(string, map[string]string) ([]zhmcclient.LPAR, error)) {
	fake.listLPARsMutex.Lock()
	defer fake.listLPARsMutex.Unlock()
	fake.ListLPARsStub = stub
}

func (fake *ZhmcAPI) ListLPARsArgsForCall(i int) (string, map[string]string) {
	fake.listLPARsMutex.RLock()
	defer fake.listLPARsMutex.RUnlock()
	argsForCall := fake.listLPARsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ZhmcAPI) ListLPARsReturns(result1 []zhmcclient.LPAR, result2 error) {
	fake.listLPARsMutex.Lock()
	defer fake.listLPARsMutex.Unlock()
	fake.ListLPARsStub = nil
	fake.listLPARsReturns = struct {
		result1 []zhmcclient.LPAR
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListLPARsReturnsOnCall(i int, result1 []zhmcclient.LPAR, result2 error) {
	fake.listLPARsMutex.Lock()
	defer fake.listLPARsMutex.Unlock()
	fake.ListLPARsStub = nil
	if fake.listLPARsReturnsOnCall == nil {
		fake.listLPARsReturnsOnCall = make(map[int]struct {
			result1 []zhmcclient.LPAR
			result2 error
		})
	}
	fake.listLPARsReturnsOnCall[i] = struct {
		result1 []zhmcclient.LPAR
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListNics(arg1 string) ([]string, error) {
	fake.listNicsMutex.Lock()
	ret, specificReturn := fake.listNicsReturnsOnCall[len(fake.listNicsArgsForCall)]
	fake.listNicsArgsForCall = append(fake.listNicsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListNicsStub
	fakeReturns := fake.listNicsReturns
	fake.recordInvocation("ListNics", []interface{}{arg1})
	fake.listNicsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) ListNicsCallCount() int {
	fake.listNicsMutex.RLock()
	defer fake.listNicsMutex.RUnlock()
	return len(fake.listNicsArgsForCall)
}

func (fake *ZhmcAPI) ListNicsCalls(stub func(string) ([]string, error)) {
	fake.listNicsMutex.Lock()
	defer fake.listNicsMutex.Unlock()
	fake.ListNicsStub = stub
}

func (fake *ZhmcAPI) ListNicsArgsForCall(i int) string {
	fake.listNicsMutex.RLock()
	defer fake.listNicsMutex.RUnlock()
	argsForCall := fake.listNicsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) ListNicsReturns(result1 []string, result2 error) {
	fake.listNicsMutex.Lock()
	defer fake.listNicsMutex.Unlock()
	fake.ListNicsStub = nil
	fake.listNicsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) ListNicsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.listNicsMutex.Lock()
	defer fake.listNicsMutex.Unlock()
	fake.ListNicsStub = nil
	if fake.listNicsReturnsOnCall == nil {
		fake.listNicsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.listNicsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) MountIsoImage(arg1 string, arg2 string, arg3 string) error {
	fake.mountIsoImageMutex.Lock()
	ret, specificReturn := fake.mountIsoImageReturnsOnCall[len(fake.mountIsoImageArgsForCall)]
	fake.mountIsoImageArgsForCall = append(fake.mountIsoImageArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.MountIsoImageStub
	fakeReturns := fake.mountIsoImageReturns
	fake.recordInvocation("MountIsoImage", []interface{}{arg1, arg2, arg3})
	fake.mountIsoImageMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) MountIsoImageCallCount() int {
	fake.mountIsoImageMutex.RLock()
	defer fake.mountIsoImageMutex.RUnlock()
	return len(fake.mountIsoImageArgsForCall)
}

func (fake *ZhmcAPI) MountIsoImageCalls(stub func(string, string, string) error) {
	fake.mountIsoImageMutex.Lock()
	defer fake.mountIsoImageMutex.Unlock()
	fake.MountIsoImageStub = stub
}

func (fake *ZhmcAPI) MountIsoImageArgsForCall(i int) (string, string, string) {
	fake.mountIsoImageMutex.RLock()
	defer fake.mountIsoImageMutex.RUnlock()
	argsForCall := fake.mountIsoImageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *ZhmcAPI) MountIsoImageReturns(result1 error) {
	fake.mountIsoImageMutex.Lock()
	defer fake.mountIsoImageMutex.Unlock()
	fake.MountIsoImageStub = nil
	fake.mountIsoImageReturns = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) MountIsoImageReturnsOnCall(i int, result1 error) {
	fake.mountIsoImageMutex.Lock()
	defer fake.mountIsoImageMutex.Unlock()
	fake.MountIsoImageStub = nil
	if fake.mountIsoImageReturnsOnCall == nil {
		fake.mountIsoImageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mountIsoImageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) QueryJob(arg1 string) (*zhmcclient.Job, error) {
	fake.queryJobMutex.Lock()
	ret, specificReturn := fake.queryJobReturnsOnCall[len(fake.queryJobArgsForCall)]
	fake.queryJobArgsForCall = append(fake.queryJobArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.QueryJobStub
	fakeReturns := fake.queryJobReturns
	fake.recordInvocation("QueryJob", []interface{}{arg1})
	fake.queryJobMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) QueryJobCallCount() int {
	fake.queryJobMutex.RLock()
	defer fake.queryJobMutex.RUnlock()
	return len(fake.queryJobArgsForCall)
}

func (fake *ZhmcAPI) QueryJobCalls(stub func(string) (*zhmcclient.Job, error)) {
	fake.queryJobMutex.Lock()
	defer fake.queryJobMutex.Unlock()
	fake.QueryJobStub = stub
}

func (fake *ZhmcAPI) QueryJobArgsForCall(i int) string {
	fake.queryJobMutex.RLock()
	defer fake.queryJobMutex.RUnlock()
	argsForCall := fake.queryJobArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) QueryJobReturns(result1 *zhmcclient.Job, result2 error) {
	fake.queryJobMutex.Lock()
	defer fake.queryJobMutex.Unlock()
	fake.QueryJobStub = nil
	fake.queryJobReturns = struct {
		result1 *zhmcclient.Job
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) QueryJobReturnsOnCall(i int, result1 *zhmcclient.Job, result2 error) {
	fake.queryJobMutex.Lock()
	defer fake.queryJobMutex.Unlock()
	fake.QueryJobStub = nil
	if fake.queryJobReturnsOnCall == nil {
		fake.queryJobReturnsOnCall = make(map[int]struct {
			result1 *zhmcclient.Job
			result2 error
		})
	}
	fake.queryJobReturnsOnCall[i] = struct {
		result1 *zhmcclient.Job
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) StartLPAR(arg1 string) (string, error) {
	fake.startLPARMutex.Lock()
	ret, specificReturn := fake.startLPARReturnsOnCall[len(fake.startLPARArgsForCall)]
	fake.startLPARArgsForCall = append(fake.startLPARArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StartLPARStub
	fakeReturns := fake.startLPARReturns
	fake.recordInvocation("StartLPAR", []interface{}{arg1})
	fake.startLPARMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) StartLPARCallCount() int {
	fake.startLPARMutex.RLock()
	defer fake.startLPARMutex.RUnlock()
	return len(fake.startLPARArgsForCall)
}

func (fake *ZhmcAPI) StartLPARCalls(stub func(string) (string, error)) {
	fake.startLPARMutex.Lock()
	defer fake.startLPARMutex.Unlock()
	fake.StartLPARStub = stub
}

func (fake *ZhmcAPI) StartLPARArgsForCall(i int) string {
	fake.startLPARMutex.RLock()
	defer fake.startLPARMutex.RUnlock()
	argsForCall := fake.startLPARArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) StartLPARReturns(result1 string, result2 error) {
	fake.startLPARMutex.Lock()
	defer fake.startLPARMutex.Unlock()
	fake.StartLPARStub = nil
	fake.startLPARReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) StartLPARReturnsOnCall(i int, result1 string, result2 error) {
	fake.startLPARMutex.Lock()
	defer fake.startLPARMutex.Unlock()
	fake.StartLPARStub = nil
	if fake.startLPARReturnsOnCall == nil {
		fake.startLPARReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.startLPARReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) StopLPAR(arg1 string) (string, error) {
	fake.stopLPARMutex.Lock()
	ret, specificReturn := fake.stopLPARReturnsOnCall[len(fake.stopLPARArgsForCall)]
	fake.stopLPARArgsForCall = append(fake.stopLPARArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StopLPARStub
	fakeReturns := fake.stopLPARReturns
	fake.recordInvocation("StopLPAR", []interface{}{arg1})
	fake.stopLPARMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *ZhmcAPI) StopLPARCallCount() int {
	fake.stopLPARMutex.RLock()
	defer fake.stopLPARMutex.RUnlock()
	return len(fake.stopLPARArgsForCall)
}

func (fake *ZhmcAPI) StopLPARCalls(stub func(string) (string, error)) {
	fake.stopLPARMutex.Lock()
	defer fake.stopLPARMutex.Unlock()
	fake.StopLPARStub = stub
}

func (fake *ZhmcAPI) StopLPARArgsForCall(i int) string {
	fake.stopLPARMutex.RLock()
	defer fake.stopLPARMutex.RUnlock()
	argsForCall := fake.stopLPARArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) StopLPARReturns(result1 string, result2 error) {
	fake.stopLPARMutex.Lock()
	defer fake.stopLPARMutex.Unlock()
	fake.StopLPARStub = nil
	fake.stopLPARReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) StopLPARReturnsOnCall(i int, result1 string, result2 error) {
	fake.stopLPARMutex.Lock()
	defer fake.stopLPARMutex.Unlock()
	fake.StopLPARStub = nil
	if fake.stopLPARReturnsOnCall == nil {
		fake.stopLPARReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.stopLPARReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *ZhmcAPI) UnmountIsoImage(arg1 string) error {
	fake.unmountIsoImageMutex.Lock()
	ret, specificReturn := fake.unmountIsoImageReturnsOnCall[len(fake.unmountIsoImageArgsForCall)]
	fake.unmountIsoImageArgsForCall = append(fake.unmountIsoImageArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.UnmountIsoImageStub
	fakeReturns := fake.unmountIsoImageReturns
	fake.recordInvocation("UnmountIsoImage", []interface{}{arg1})
	fake.unmountIsoImageMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) UnmountIsoImageCallCount() int {
	fake.unmountIsoImageMutex.RLock()
	defer fake.unmountIsoImageMutex.RUnlock()
	return len(fake.unmountIsoImageArgsForCall)
}

func (fake *ZhmcAPI) UnmountIsoImageCalls(stub func(string) error) {
	fake.unmountIsoImageMutex.Lock()
	defer fake.unmountIsoImageMutex.Unlock()
	fake.UnmountIsoImageStub = stub
}

func (fake *ZhmcAPI) UnmountIsoImageArgsForCall(i int) string {
	fake.unmountIsoImageMutex.RLock()
	defer fake.unmountIsoImageMutex.RUnlock()
	argsForCall := fake.unmountIsoImageArgsForCall[i]
	return argsForCall.arg1
}

func (fake *ZhmcAPI) UnmountIsoImageReturns(result1 error) {
	fake.unmountIsoImageMutex.Lock()
	defer fake.unmountIsoImageMutex.Unlock()
	fake.UnmountIsoImageStub = nil
	fake.unmountIsoImageReturns = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) UnmountIsoImageReturnsOnCall(i int, result1 error) {
	fake.unmountIsoImageMutex.Lock()
	defer fake.unmountIsoImageMutex.Unlock()
	fake.UnmountIsoImageStub = nil
	if fake.unmountIsoImageReturnsOnCall == nil {
		fake.unmountIsoImageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unmountIsoImageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) UpdateLparProperties(arg1 string, arg2 *zhmcclient.LparProperties) error {
	fake.updateLparPropertiesMutex.Lock()
	ret, specificReturn := fake.updateLparPropertiesReturnsOnCall[len(fake.updateLparPropertiesArgsForCall)]
	fake.updateLparPropertiesArgsForCall = append(fake.updateLparPropertiesArgsForCall, struct {
		arg1 string
		arg2 *zhmcclient.LparProperties
	}{arg1, arg2})
	stub := fake.UpdateLparPropertiesStub
	fakeReturns := fake.updateLparPropertiesReturns
	fake.recordInvocation("UpdateLparProperties", []interface{}{arg1, arg2})
	fake.updateLparPropertiesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *ZhmcAPI) UpdateLparPropertiesCallCount() int {
	fake.updateLparPropertiesMutex.RLock()
	defer fake.updateLparPropertiesMutex.RUnlock()
	return len(fake.updateLparPropertiesArgsForCall)
}

func (fake *ZhmcAPI) UpdateLparPropertiesCalls(stub func(string, *zhmcclient.LparProperties) error) {
	fake.updateLparPropertiesMutex.Lock()
	defer fake.updateLparPropertiesMutex.Unlock()
	fake.UpdateLparPropertiesStub = stub
}

func (fake *ZhmcAPI) UpdateLparPropertiesArgsForCall(i int) (string, *zhmcclient.LparProperties) {
	fake.updateLparPropertiesMutex.RLock()
	defer fake.updateLparPropertiesMutex.RUnlock()
	argsForCall := fake.updateLparPropertiesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *ZhmcAPI) UpdateLparPropertiesReturns(result1 error) {
	fake.updateLparPropertiesMutex.Lock()
	defer fake.updateLparPropertiesMutex.Unlock()
	fake.UpdateLparPropertiesStub = nil
	fake.updateLparPropertiesReturns = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) UpdateLparPropertiesReturnsOnCall(i int, result1 error) {
	fake.updateLparPropertiesMutex.Lock()
	defer fake.updateLparPropertiesMutex.Unlock()
	fake.UpdateLparPropertiesStub = nil
	if fake.updateLparPropertiesReturnsOnCall == nil {
		fake.updateLparPropertiesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateLparPropertiesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *ZhmcAPI) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cancelJobMutex.RLock()
	defer fake.cancelJobMutex.RUnlock()
	fake.createHipersocketMutex.RLock()
	defer fake.createHipersocketMutex.RUnlock()
	fake.createNicMutex.RLock()
	defer fake.createNicMutex.RUnlock()
	fake.deleteHipersocketMutex.RLock()
	defer fake.deleteHipersocketMutex.RUnlock()
	fake.deleteJobMutex.RLock()
	defer fake.deleteJobMutex.RUnlock()
	fake.deleteNicMutex.RLock()
	defer fake.deleteNicMutex.RUnlock()
	fake.getLparPropertiesMutex.RLock()
	defer fake.getLparPropertiesMutex.RUnlock()
	fake.getNicPropertiesMutex.RLock()
	defer fake.getNicPropertiesMutex.RUnlock()
	fake.listAdaptersMutex.RLock()
	defer fake.listAdaptersMutex.RUnlock()
	fake.listCPCsMutex.RLock()
	defer fake.listCPCsMutex.RUnlock()
	fake.listLPARsMutex.RLock()
	defer fake.listLPARsMutex.RUnlock()
	fake.listNicsMutex.RLock()
	defer fake.listNicsMutex.RUnlock()
	fake.mountIsoImageMutex.RLock()
	defer fake.mountIsoImageMutex.RUnlock()
	fake.queryJobMutex.RLock()
	defer fake.queryJobMutex.RUnlock()
	fake.startLPARMutex.RLock()
	defer fake.startLPARMutex.RUnlock()
	fake.stopLPARMutex.RLock()
	defer fake.stopLPARMutex.RUnlock()
	fake.unmountIsoImageMutex.RLock()
	defer fake.unmountIsoImageMutex.RUnlock()
	fake.updateLparPropertiesMutex.RLock()
	defer fake.updateLparPropertiesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ZhmcAPI) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ zhmcclient.ZhmcAPI = new(ZhmcAPI)
